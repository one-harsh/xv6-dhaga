xv6-dhaga

Dhaga Hart-integrated Asynchrony Governance Apparatus

Game plan:

Stage 1: Decouple proc and thread bookkeeping, no functional change
1) Split out struct proc into struct pcb and struct tcb
2) Swap out static struct proc[NPROC] with struct tcb[NTHREAD]
3) Create an allocthread(), move the right subset of responsibilities from allocproc() over and invoke from there
4) Create a freethread(), move the right subset of responsibilities from freeproc() over and invoke from there
5) Get things back to a functional state with usertests passing

Stage 2: Thread creation support, with concurrent execution across multiple harts
1) Add sys call to support thread_create(), to alloc new thread for the process
    call allocthread(), give it a new stack offset from the current highest stack.
2) Implement TLB shootdown whenever the pagetable is modified
    sfence_vma() from riscv.h flushes TLB on current hart...
    We have to do all of the harts running threads from the same process.
    <notes below, probably need to follow up with professor>
3) Add some user-space program that uses this functionality, verify concurrent execution and TLB shootdown

Stage 3: Add ability for thread synchronization
3) Add sys call to support thread_join(tid), to wait for a specific other thread
4) Add a waiting state in the tcb, and keep track of the id of the other thread it's waiting on
5) Add sys call to support thread_exit(), which exits the thread, but not the process
6) When a thread exits
    Set to runnable any thread that was waiting for exiting thread
    Clean up exiting thread's stack.
7) Decide if there is a special "main thread" for the application, which if it thread exits, the whole process exits
    If so, then keep track in the pcb of which one that is
    If not, then implement automatic process exit when last thread exits

Stage 4+: Optional elements and stretch goals
*) Add a sys call to support thread yields
*) Add ability to join with any / all other threads
*) When allocating threads, choose the 'highest' available stack slot, in case exiting threads have left a gap

Notes:
> TLB shootdown
See the comment here: https://stackoverflow.com/a/48465584
"that particular TLB entry is invalidated in all of the cores ... by the OS. 
The hardware doesn't do this automatically; the kernel has to send inter-processor interrupts 
or otherwise signal the kernel on other cores if they're currently running tasks that use the
page table it just modified."

Two components of TLB shootdown:

1) Raise a software interrupt on all other harts 
    HLIC mentioned here:
    https://www.kernel.org/doc/Documentation/devicetree/bindings/interrupt-controller/riscv%2Ccpu-intc.txt

    We need "software interrupt" a.k.a "interprocessor interrupt" / IPI

    w_sip() only does this for current hart
    page 58 here https://courses.cs.washington.edu/courses/csep551/19au/readings/riscv-priv.pdf  
    "Interprocessor interrupts are sent to other harts by implementation-specific means, which will
    ultimately cause the SSIP bit to be set in the recipient hart’s sip register."

    So... we have to dig into what the qemu risc-v hart impl has...

    > Github issue "WFI doesn't return when a IPI is issued" (https://github.com/riscv/riscv-qemu/issues/132)
    seems to imply that we do have IPI support...
    
    > Conference deck that says they added IPI
    https://content.riscv.org/wp-content/uploads/2017/12/Wed1712_qemu_McNamara.pdf

    https://github.com/riscv/riscv-qemu/wiki says CLINT supports IPI
    SiFive CLINT (Core Local Interruptor) for Timer interrupts and IPIs

    Do we take software interrupts in machine mode, or supervisor mode?
    


2) Handle the interrupt in each hart by flushing TLB if necessary
    If the receiving hart has interrupts off, then it's not running a user thread anyway.
    If it does get interrupted, then the trap handler should see if:
        a) It is a software interrupt due to TLB shootdown
        b) The pid for which the pagetable is being modified is the same.
    If both true, then call sfence_vma() and then return to executing the thread.

------------------

https://patchwork.kernel.org/patch/11102443/
[v2] RISC-V: Optimize tlb flush path.
In RISC-V, tlb flush happens via SBI which is expensive.
If the target cpumask contains a local hartid, some cost
can be saved by issuing a local tlb flush as we do that
in OpenSBI anyways. There is also no need of SBI call if
cpumask is empty.

Do a local flush first if current cpu is present in cpumask.
Invoke SBI call only if target cpumask contains any cpus
other than local cpu.

Signed-off-by: Atish Patra <atish.patra@wdc.com>
---
 arch/riscv/include/asm/tlbflush.h | 37 ++++++++++++++++++++++++++-----
 1 file changed, 31 insertions(+), 6 deletions(-)

--------------

https://github.com/riscv/opensbi/blob/master/lib/utils/sys/clint.c


void clint_ipi_send(u32 target_hart) WOOHOO

https://github.com/riscv/riscv-sbi-doc/blob/master/riscv-sbi.adoc


-------
https://forums.sifive.com/t/documentation-for-clint/155

https://sifive.cdn.prismic.io/sifive%2Fc89f6e5a-cf9e-44c3-a3db-04420702dcc1_sifive+e31+manual+v19.08.pdf

Page 24 boom

F6.2 MSIP Registers
Machine-mode software interrupts are generated by writing to the memory-mapped control register msip. Each msip register is a 32-bit wide WARL register where the upper 31 bits are tied to
0. The least significant bit is reflected in the MSIP bit of the mip CSR. Other bits in the msip register are hardwired to zero. On reset, each msip register is cleared to zero.
Software interrupts are most useful for interprocessor communication in multi-hart systems, as
harts may write each other’s msip bits to effect interprocessor interrupts

Seems like set the mip register??

https://github.com/riscv/opensbi/blob/75f903dd78e2419057d04e14d6720fde764cbf78/lib/sbi/sbi_ipi.c

mb/emulation/qemu-riscv: Implement ipi using clint to enable smp in qemu/spike:
https://review.coreboot.org/c/coreboot/+/35246


-----------------------------------------------------
Sending IPI:

msip is memory mapped

in CLINT documentation
The 4 byte (32 bit) registers after the "msip for hart0" (which == CLINT addr) are the msips for the other harts
(extrapolating from the fact that mtimecmp has analogous structure, and xv6 already uses that in memlayout.h + start.C)

Therefore, we can 'address' the other harts. yay.

----------------------------------------------------
Receiving IPI:

Seems like we have to use the machine-mode trap.
Currently mtvec is used (I think) in direct mode, since we are not concerned about mcause at all in xv6.

Do we have to change it so that we now do care about mcause, so that it's a vectored mtvec instead?
That would mean we get to set up a separate trap handler for IPIs.

However, we want to somehow communicate when we translate this machine-mode mode 'mip' situation 
to a supervisor-mode 'sip.SSIP' situation, that  this was not a timer interrupt, it's an IPI. How?

https://people.eecs.berkeley.edu/~krste/papers/riscv-privileged-v1.9.1.pdf, page 49
"Interprocessor interrupts are sent to other harts by means of SBI calls, which will ultimately cause
the SSIP bit to be set in the recipient hart’s sip register."

Is mscratch the answer?


